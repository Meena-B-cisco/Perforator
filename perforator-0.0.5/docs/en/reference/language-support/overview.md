# Languages supported by Perforator

Perforator supports different kinds of programming languages and language runtimes. This page describes the current status of language support.

There are different tiers of support for different languages and runtimes:
- Tier 0: C++. This is our primary focus. Perforator has some advanced features for C++ that are not yet available for other languages.
- Tier 1: Native languages like Rust, C, Go. These should work fine without any configuration in most cases (the only requirement is debug symbols availability).
- Tier 2: Python and Java. We have experimental support for these, which have known limitations and runtime requirements.

## Native languages
Support for native (compiled to machine code) languages is the most important target for the Perforator. We strive to implement this as good as possible without complex requirements on profiled binaries like `-fno-omit-frame-pointer` switch. The only requirements are:
- The presence of debugging symbols either in production builds or separate debug info providers like debuginfod. It is simply not possible to map raw instructions to source code without debug symbols.
- The presence of `.eh_frame` section which is generated by default by modern compilers. This section is used by exception runtimes in some popular native languages, but executables without exceptions also have this section unless switch `-fno-asynchronous-unwind-tables` is specified.

Incomplete list of the native languages we tested Perforator on successfully:

### C & C++
Initially Perforator was developed to profile C++, our main language for high-performance services inside Yandex. We profile thousands of C & C++ binaries in different configurations.

### Golang
Golang is a very easy language for profiling due to the always-available frame pointers [since 2016](https://github.com/golang/go/issues/15840). The only requirement for profiling is debug symbols availability.

### Rust
We have not tested Rust profiling as extensively as C++, but a few tests show that Rust is profiled correctly. The only difference from C / C++ is Rust-specific function name mangling which is not correctly parsed in some cases. We are going to address this issue soon.

## Interpreted languages
### Python
Perforator supports Python with some additional requirements on the runtime. See [this page](./python/profiling.md) for more info. As for now, other interpreted languages are not supported. Please file an issue on GitHub if you have a language you think is worth supporting.

## JIT-compiled languages
### Java
We have an experimental implementation of the [Java](./java/) profiler which requires users to set some flags for the JVM runtime. We are working on zero-configuration Java support.

## Other languages
Probably a lot of less popular native languages can be profiled out of the box using either frame pointers or `.eh_frame`. We have seen valid profiles from Zig applications, for example. The best way to check whether your language/application is supported is to profile it.

Many interpreted & JIT-compiled languages can be profiled using [perf-pid.map](https://git.kernel.org/pub/scm/linux/kernel/git/perf/perf-tools-next.git/tree/tools/perf/Documentation/jit-interface.txt?h=perf-tools-next) JIT interface initially developed for perf. Perforator natively supports perfmaps, so when you enable them on the application side it should just work. Search for words like "perf", "frame pointers" and "perf-pid.map" in your language's documentations. For example, [NodeJS](https://nodejs.org/en/learn/diagnostics/poor-performance/using-linux-perf), [PHP](https://wiki.php.net/rfc/jit), and [Python](https://docs.python.org/3/c-api/perfmaps.html) can be profiled like this. See [perfmap reference](../perfmap.md) for more details.

## Language support policy
While we obviously cannot support every language, we are open to contributions and suggestions. Please file an issue on GitHub to describe your use case.
